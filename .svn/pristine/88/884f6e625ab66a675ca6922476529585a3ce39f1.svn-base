package uk.ac.ebi.biomodels.tools;


import uk.ac.ebi.biomodels.data.Anno;
import uk.ac.ebi.biomodels.data.Bag;
import uk.ac.ebi.biomodels.data.ModelElement;

import java.io.File;
import java.io.IOException;
import javax.xml.stream.XMLStreamException;
import org.sbml.jsbml.Annotation;
import org.sbml.jsbml.CVTerm;
import org.sbml.jsbml.Model;
import org.sbml.jsbml.SBMLDocument;
import org.sbml.jsbml.SBMLReader;
import org.sbml.jsbml.SBase;
import org.sbml.jsbml.Species;


/**
 * Extracts some model annotations (mainly from species) with the objective to use those in the Reactome Analysis tool.
 * 
 * @author Camille Laibe
 * @version 20140704
 */
public class ExtractAnnoFromFile
{
	private static final String MODELS_FOLDER_PATH = "/scratch/camille/workspace/eclipse/BioModels_annoExtractionForReactomeLinking/data/";
	private static final String NAMESPACE_UNIPROT = "uniprot";
	private static final String NAMESPACE_CHEBI = "chebi";
	private static final String NAMESPACE_CHEMBL_COMPOUND = "chembl.compound";
	private static final String NAMESPACE_ENSEMBL = "ensembl";
	
	
	public static void main(String[] args)
	{
		Integer filesCounter = 0;
		Integer modelsCounter = 0;
		
		// explore the files contained in the provided folder
		File modelsFolder = new File(MODELS_FOLDER_PATH);
		if (modelsFolder.isDirectory())
		{
			File[] models = modelsFolder.listFiles();
			
			// go through all the model files
			for (File modelFile: models)
	        {
				filesCounter ++;
				
				// let's be sure this is a model file
				if ((modelFile.isFile()) && (modelFile.getName().matches("(BIOMD|MODEL)\\d{10}.xml")))
				{
					SBMLReader reader = new SBMLReader();
					SBMLDocument model = null;
					try
					{
						model = reader.readSBML(modelFile);
					}
					catch (XMLStreamException e)
					{
						System.err.println("XMLStreamException raised while reading SBML file: " + modelFile.getName());
						System.err.println(e.getMessage());
					}
					catch (IOException e)
					{
						System.err.println("IOException raised while reading SBML file: " + modelFile.getName());
						System.err.println(e.getMessage());
					}
					
					if (null !=  model)
					{
						modelsCounter ++;
						extractAnno(model.getModel());
					}
					else
					{
						System.err.println("Cannot read model: " + modelFile.getName());
					}
				}
				else
				{
					System.err.println("\nWARNING: '" + modelFile.getName() + "' is not a model file and therefore has been ignored!");
				}
	        }
		}
		else
		{
			System.err.println("The provided parameter (" + MODELS_FOLDER_PATH + ") is not a folder!");
		}
		
		System.out.println("\n" + modelsCounter + " models processed (" + filesCounter + " files in total).");
	}
	
	/**
	 * Extracts all the necessary annotations.
	 * WARNING: currently only display the information on the console.
	 */
	private static void extractAnno(Model model)
	{
		// gets model name and id
		System.out.println("\nModel: " + model.getName() + " (" + model.getId() + ")");   // model.getId() is not reliable
		// extracts species' annotations
		System.out.println("---");
		Integer countIds = 0;
		Integer componentsWithoutId = 0;
		for (Species species: model.getListOfSpecies())
		{
			ModelElement component = extractComponentAnno(species);
			Integer countElt = displayRelevantAnnotation(component);
			countIds += countElt;
			if (hasRelevantAnno(component))
			{
				componentsWithoutId += 1;
			}
		}
		System.out.println("---");
		// summary
		System.out.println("Nb SBML species:       " +  model.getSpeciesCount());
		System.out.println("Nb identifiers:        " + countIds);
		System.out.println("Nb species without id: " + componentsWithoutId);
		System.out.println("Taxonomy: " + getModelTaxon(model));
	}
	
	
	/**
	 * Checks whether a given model component has any relevant annotation(s) attached to it.
	 */
	private static boolean hasRelevantAnno(ModelElement component)
	{
		Boolean hasAnno = true;
		
		if ((findAllAnnotationFromDataCollection(component, NAMESPACE_UNIPROT) == 0) && (findAllAnnotationFromDataCollection(component, NAMESPACE_CHEBI) == 0) && (findAllAnnotationFromDataCollection(component, NAMESPACE_CHEMBL_COMPOUND) == 0) && (findAllAnnotationFromDataCollection(component, NAMESPACE_ENSEMBL) == 0))
		{
			hasAnno = false;
		}
		
		return hasAnno;
	}
	
	
	/**
	 * Extract the necessary annotation from a model component.
	 * @param species
	 */
	private static ModelElement extractComponentAnno(SBase component)
	{
		ModelElement element = new ModelElement();
		
		for (CVTerm cvTerm: component.getCVTerms())
		{
			Bag bag = new Bag();
			
			bag.setQualifier(getQualifier(cvTerm));
			// retrieves all the URIs
			for (String uri: cvTerm.getResources())
			{
				Anno anno = new Anno();
				anno.setUri(uri);
				anno.setEntityId(extractIdFromUri(uri));
				anno.setNamespace(extractNamespaceFromUri(uri));
				
				bag.addAnnotation(anno);
			}
			
			//System.out.println(bag.toString());
			
			element.addBag(bag);
		}
		
		return element;
	}
	
	
	/**
	 * Extracts the taxonomical annotation from the model object.
	 * Only considers "bqbiol:occursIn" or "bqbiol:hasTaxon" qualifiers.
	 */
	private static String getModelTaxon(Model model)
	{
		String taxon = null;
		Annotation modelAnno = model.getAnnotation();
		for (CVTerm cvTerm: modelAnno.getListOfCVTerms())
		{
			String qualifier = null;
			qualifier = getQualifier(cvTerm);
			
			// retrieves all the URIs
			for (String uri: cvTerm.getResources())
			{
				//System.out.println("- " + qualifier + " " + uri );
				if ((qualifier.equalsIgnoreCase("bqbiol:occursIn") || qualifier.equalsIgnoreCase("bqbiol:hasTaxon")) && (uri.contains("taxonomy")))
				{
					taxon = extractIdFromUri(uri);
				}
			}
		}
		
		return taxon;
	}
	
	
	/**
	 * Get the qualifier's name from a CVTerm.
	 */
	private static String getQualifier(CVTerm cvTerm)
	{	
		String qualifier = null;
		String namespacePrefix = cvTerm.isModelQualifier() ? "bqmodel" : "bqbiol";            		
		String qualifierName = null;
		
		if (cvTerm.isModelQualifier())
		{
			qualifierName = cvTerm.getModelQualifierType().getElementNameEquivalent(); 
		}
		else
		{
			qualifierName = cvTerm.getBiologicalQualifierType().getElementNameEquivalent();
		}
		qualifier = namespacePrefix + ":" + qualifierName;
		
		return qualifier;
	}
	
	
	/**
	 * Displays all annotations of a given SBML element which are relevant for the Reactome data analyis tool. 
	 */
	private static Integer displayRelevantAnnotation(ModelElement component)
	{
		Integer counter = 0;
		Integer counterTmp = 0;
		
		counterTmp = findAllAnnotationFromDataCollection(component, NAMESPACE_UNIPROT);
		if (counterTmp > 0)   // some UniProt annotation found
		{
			printAllAnnotationFromDataCollection(component, NAMESPACE_UNIPROT);
			counter += counterTmp;
		}
		else   // no UniProt annotation found
		{
			counterTmp = findAllAnnotationFromDataCollection(component, NAMESPACE_CHEBI);
			if (counterTmp > 0)   // some ChEBI annotation found
			{
				printAllAnnotationFromDataCollection(component, NAMESPACE_CHEBI);
				counter += counterTmp;
			}
			else   // no ChEBI annotation found
			{
				counterTmp = findAllAnnotationFromDataCollection(component, NAMESPACE_CHEMBL_COMPOUND);
				if (counterTmp > 0)   // some ChEMBL Compound annotation found
				{
					printAllAnnotationFromDataCollection(component, NAMESPACE_CHEMBL_COMPOUND);
					counter += counterTmp;
				}
				else   // no ChEMBL Compound annotation found
				{
					counterTmp = findAllAnnotationFromDataCollection(component, NAMESPACE_ENSEMBL);
					if (counterTmp > 0)   // some Ensembl annotation found
					{
						printAllAnnotationFromDataCollection(component, NAMESPACE_ENSEMBL);
						counter += counterTmp;
					}
				}
			}
		}
		
		return counter;
	}
	
	
	/**
	 * Finds and counts all the annotation of a SBML component from a given data collection.
	 */
	private static Integer findAllAnnotationFromDataCollection(ModelElement component, String namespace)
	{
		Integer counter = 0;
		
		if (null != component.getBags())
		{
			for (Bag bag: component.getBags())
			{
				for (Anno anno: bag.getAnnotations())
				{
					if (anno.getNamespace().equalsIgnoreCase(namespace))
					{
						counter ++;
					}
				}
			}
		}
		
		return counter;
	}
	
	
	/**
	 * Prints all the annotation of a SBML component from a given data collection.
	 */
	private static void printAllAnnotationFromDataCollection(ModelElement component, String namespace)
	{
		for (Bag bag: component.getBags())
		{
			for (Anno anno: bag.getAnnotations())
			{
				if (anno.getNamespace().equalsIgnoreCase(namespace))
				{
					System.out.println(anno.getEntityId());
				}
			}
		}
	}
	
	
	/**
	 * Extracts the entity identifier from an Identifiers.org URI.
	 * E.g. http://identifiers.org/taxonomy/8292   >>>  8292 
	 */
	private static String extractIdFromUri(String uri)
	{
		return uri.substring(uri.lastIndexOf("/") + 1);
	}
	
	
	/**
	 * Extracts the namespace from an Identifiers.org URI.
	 * E.g. http://identifiers.org/taxonomy/8292   >>>  taxonomy
	 */
	private static String extractNamespaceFromUri(String uri)
	{
		return uri.substring(23, uri.indexOf("/", 24));
	}
}
